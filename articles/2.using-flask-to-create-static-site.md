# Using flask to generate your static website

This is a post on me using flask jinja templating to "standardise" <a href="karlcch.com">my static website</a>

## Introductions

Why flask? There are indeen meny tools that can be used to create static webiste, however all of them have some kind of limitations.<br />
I personally don't have much experience with those tools myself. Plus, I like to be in controll be create the thing from scratch.<br />
Flask in this project is only used to create routes while Jinja2 do all the work of putting everything togethere "standerdly".<br />
I am stil working on migrating my <a href="https://pages.github.com/">github pages</a> page for posts like this to my site. Flask is the middle ground for me between throughing everthing to a wordpress host and hosting on a bucket(free).<br />
Also checkout: 

- <a href="https://github.karlcch.com/articles/1.S3_CF_Site">Using S3 with CloudFront to host Static Websites for FREE
- <a href="https://github.com/ltekme/karlcch">Project github link</a>
- <a href="karlcch.com">karlcch.com</a>

## credits

- Flask: https://github.com/pallets/flask
- Flask Sitemapper: https://github.com/h-janes/flask-sitemapper
- Frozen-Flask: https://github.com/Frozen-Flask/Frozen-Flask
- python-dotenv: https://github.com/theskumar/python-dotenv

## Reason to use tempalating

There are meny pages to that have the same content over and over such as the head of the html and the banner itself. <br/>

In the future when I expand the site, things would only get more complicated. I have a few options:

- Migrate to wordpress
- Migrate all my posts to linkedin
- Flask

## Ranting about wordress, hosting, services

I personally don't like wordpress. The biggest reason being the controll pannel is directly accessable by url by anyone. You can secure it, however just is idea of it feels off. Trust me, it's not a good idea to expose you controll pannel to a publically accable url. 

Just look for sites hosted using wordpress and type in `/wp-admin`. You would be surprised by how many site owner didn't do anything about to protect the page. 

I not saying wordpress is bad, it has it's nesh, and every implimentation of every system has it's flaws. But this wp-admin thing has been bothering me since I once used it untill I moved to a different option. 

Besides, having a host with a service exposed to the internet is not really my cup of tea. Back when I was hosting my site on a vm, viewing the logs of apach2 was one of my favourit free time activity, I constently find random host hitting `/wp-admin`, `/wp/config`, `.config`, `.c9` to try to get something out of the host. It's a fun activity and a greate time killer.

`Looking at Apache Log to see what bots are targeting and searching up ip addresses that hits on some random urlpath that tries to do sqlinjection on a html hosted dir with no logic on the server whatsoever`

come on, I don't even have a database back then. it is fun to see this this poping up once in a while.

| Time                 | Type | Path                | HTTP ver | Response |
| -------------------- | ---- | ------------------- | -------- | -------- |
| 13/Apr/2023:11:29:03 | GET  | /.aws/credentials   | HTTP/1.1 | 404      |
| 13/Apr/2023:11:29:03 | GET  | /.wp-config.php.swp | HTTP/1.1 | 404      |
| 13/Apr/2023:11:29:03 | GET  | /admin/phpinfo.php  | HTTP/1.1 | 404      |

Fun times.

## Linkedin is a good platform

Linkedin is a very good place to share things like this it's just too simple for me.

## Flask

At the time of writing, I am already using cloudfront and an s3 bucket to host my site, all I needed is a way to standerdise my htmls.

So flask it is. And for those when wanted to say node.js, I tried, it was way too complicated for my usecase. I just finished an assignment project that require flask. I just want to get on with my life. Semester 3 is hell.


# project base

```
.
├── app
│   ├── __init__.py
│   ├── pages.py
│   ├── resources
│   │   └── favicon.ico
│   ├── routes.py
│   ├── static
│   │   ├── images
│   │   │   ├── icon.webp
│   │   └── styles
│   │       ├── main.css
│   │       └── normalize.css
│   └── templates
│       ├── errors.html.j2
│       ├── index.html.j2
│       ├── layout.html.j2
│       └── robots.txt
├── build.py
├── requirements.txt
└── run.py
```
checkout the github repo for more details about it

# Encounters

- Frozen-Flask page build
- sitemap.xml
- robots.txt
- favicon.ico
- /static
- Full URL path on build
- built dir
- S3 error page

## Frozen-Flask page build

when I decided on using `Frozen-Flask` I didn't reliase it would copy all the contents of the static folder to the build destination. Thus causing some files to be duplicated such as:

- favicon.ico
- robots.txt
- sitemap.xml

## sitemap

After looking at some of the options out there I landed on flask-sitemapper as it was one of the simplest of them all. At first I decided to use https://flask-sitemap.readthedocs.io/en/latest/ however after reading the documentation, this is too complicated for my usecase, after stumbling around when I almost decided to create my own I found https://github.com/h-janes/flask-sitemapper a simple yet elegent solution to my problem.

```
# app/__init__.py
sitemapper = Sitemapper(https=bool(app.config.get("URL_SCHEME") == "https"))
sitemapper.init_app(app)
```

```
# app/routes.py
@sitemapper.include(lastmod="2024-05-09")
@app.route('/')
def index():
    return render_template('index.html.j2', title='KarlCCH | Home', metadata_description='Home of karlcch', config=app.config)
```
along with
```
# app/routes.py
@app.route("/sitemap.xml")
def sitemap():
    return sitemapper.generate()
```
only one line is need to include the route to the sitemap `@sitemapper.include(lastmod="2024-05-09")`.

## robots
This is file is a bit complicated as I cannot just send a text string to the client for some reason.

```
# app/routes.py
@app.route('/robots.txt')
def robots():
    return '''# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:
sitemap: karlcch.com/sitemap.xml'''
```
but this has a few problem in itself. First I would be hardcoding the hostname of the site.<br />
Lighthouse keeps complaining an improper robots.txt so I had to send a file instead of string.<br/>

```
# app/routes.py
return send_from_directory('resources', 'robots.txt')
```

I can use `flask.send_from_directory` to send the file however I need to figure out how to change the file based on the hostname.<br />
I can use python's <a href="https://docs.python.org/3/library/functions.html">`open`</a> to modify the file on the fly, but this would create another problem down the road.<br />
consulting the documentation I found <a href="https://flask.palletsprojects.com/en/3.0.x/api/#flask.send_file">`flask.send_file`</a> this allows me to send `open()` object as a file to the client.

All I need to do now is to encode the robots string to a <a href="https://docs.python.org/3/library/io.html#binary-i-o">`BytesIO()`</a> object and use `flask.send_file` to send the string as a file.

```
# app/routes.py
mem = BytesIO()
mem.write(robot_file.encode('utf8'))
mem.seek(0)

return send_file(mem, mimetype='text/plain', as_attachment=False, download_name='robots.txt')
```

done. I can now use <a href="https://flask.palletsprojects.com/en/2.3.x/templating/">`flask.render_template`</a> to render the file with hostname

```
# app/routes.py
robot_file = render_template('robots.txt', hostname=hostname)
```

to get the hostname I need to have 2 things, `HTTPS` and `SERVER_NAME` should be easy

```
# app/routes.py
hostname = app.config.get('SERVER_NAME') or request.host
if app.config.get('URL_SCHEME') == 'https':
    hostname = 'https://' + hostname
else:
    hostname = 'http://' + hostname
```

piecing everything together

```
# app/routes.py
@app.route('/robots.txt')
def robots():
    # get hostname
    hostname = app.config.get('SERVER_NAME') or request.host
    if app.config.get('URL_SCHEME') == 'https':
        hostname = 'https://' + hostname
    else:
        hostname = 'http://' + hostname
    # render file
    robot_file = render_template('robots.txt', hostname=hostname)
    # store to memory as a virtaul file
    mem = BytesIO()
    mem.write(robot_file.encode('utf8'))
    mem.seek(0)

    return send_file(mem, mimetype='text/plain', as_attachment=False, download_name='robots.txt')
```

That's a complete robots.txt lighthouse is now happpy

## Static content

Flask <a href="https://flask.palletsprojects.com/en/2.3.x/api/#flask.url_for">`url_for`</a> has a built in static content route which allow you to point to every file in the `static` folder.
This creates a problem.

Everythin in that folder is now in the root of the site. To prevent anything from breaking and making it `CDN frendly`

I decided to put all static content in the `/static` folder of the HTML. Thus this route was born.

```
# app/routes.py
@app.route('/static/<path:path>')
def static_content(path):
    return send_from_directory('static', path)
```

in stead of using the build-in static route, using this special route allow all static content present in the built staic site folder.

## Favicon

This file is a bit complicated as I would like. To show the favicon I can just put it in the static folder and be done with it.

However as mentioned before, duplicated files.

``` 
# app/routes.py
@app.route('/favicon.ico')
def favicon_ico():
    return send_from_directory('resources', 'favicon.ico')
```
create a new folder called `resources`. Move the file there with a route pointing to the file. 

Problem solved 

## Full URL path on build

when writing the flask app, path to static files should not contain the `domain name/host` in the url path. This creates a problem. I need all <a href="https://flask.palletsprojects.com/en/2.3.x/api/#flask.url_for">`url_for`</a> to have be an external path which would need 2 things.

- _external
- _scheme

which created 2 more <a href="https://flask.palletsprojects.com/en/2.3.x/api/#flask.Flask.config">`flask.config`</a> which created

```
# build.py
build_config = dict(dotenv_values('.buildenv'))

if __name__ == '__main__':
    app.config.from_mapping(build_config)
```
with these 2 in .build
```
# .buildenv
SERVER_NAME=localhost
URL_SCHEME=http
```
and addition args on every <a href="https://flask.palletsprojects.com/en/2.3.x/api/#flask.url_for">`url_for`</a>

```
# *.html.j2 templates
{{ url_for('static_content', path='images/icon.webp', _scheme=config.get('URL_SCHEME')) }}
```

whem a `_scheme` arg is present `url_for` automatically look for a `SERVER_NAME` so that value don't need to be set.

## Build dir

this should be simple

```
.buildenv
BUILD_DESTINATION=../.build
```

```
# build.py
app.config["FREEZER_DESTINATION"] = build_config.get('BUILD_DESTINATION') or os.path.join(basedir, '.build')
freezer = Freezer(app)
freezer.freeze()
```

done. Try to get the build dir from env, when not present use the default `.build` dir next to `build.py`

## S3 error page

to host on s3 I need flask to also generate the error document

```
# app/route.py
@app.route('/errors.html')
def error_file():
    return render_template('errors.html.j2', title='karlcch', config=app.config)

@app.errorhandler(404)
def error_not_found(err):
    return error_file(), 404
```
done

# File overview

### app/\_\_init\_\_.py
```
from flask import Flask
from flask_sitemapper import Sitemapper

app = Flask(__name__)

sitemapper = Sitemapper(https=bool(app.config.get("URL_SCHEME") == "https"))
sitemapper.init_app(app)

# routes must be placed at the bottom
from . import routes
```
### app/routes.py
```
from io import StringIO, BytesIO
from flask import render_template, send_from_directory, send_file, request
from . import app, sitemapper, pages

@app.route('/static/<path:path>')
def static_content(path):
    return send_from_directory('static', path)

@app.route('/favicon.ico')
def favicon_ico():
    return send_from_directory('resources', 'favicon.ico')

@app.route('/robots.txt')
def robots():
    # get hostname
    hostname = app.config.get('SERVER_NAME') or request.host
    if app.config.get('URL_SCHEME') == 'https':
        hostname = 'https://' + hostname
    else:
        hostname = 'http://' + hostname
    # render file
    robot_file = render_template('robots.txt', hostname=hostname)
    # store to memory as a virtaul file
    mem = BytesIO()
    mem.write(robot_file.encode('utf8'))
    mem.seek(0)

    return send_file(mem, mimetype='text/plain', as_attachment=False, download_name='robots.txt')

@app.route('/errors.html')
def error_file():
    return render_template('errors.html.j2', title='karlcch', config=app.config)

@app.errorhandler(404)
def error_not_found(err):
    return error_file(), 404

@app.route("/sitemap.xml")
def sitemap():
    return sitemapper.generate()
```
### app/pages.py
```
from flask import render_template
from . import sitemapper, app

@sitemapper.include(lastmod="2024-05-09")
@app.route('/')
def index():
    return render_template('index.html.j2', title='KarlCCH | Home', metadata_description='Home of karlcch', config=app.config)
```
### build.py
```
from dotenv import dotenv_values
import os
from flask_frozen import Freezer
from app import app

basedir = os.path.dirname(__file__)

build_config = dict(dotenv_values('.buildenv'))

if __name__ == '__main__':
    app.config.from_mapping(build_config)
    app.config["FREEZER_DESTINATION"] = build_config.get('BUILD_DESTINATION') or os.path.join(basedir, '.build')
    freezer = Freezer(app)
    freezer.freeze()
```

Check out he project repo for more addition fun stuff

https://github.com/ltekme/karlcch/

and the rest left for me to continue. 

### additional reads

- https://www.youtube.com/watch?v=a2D4bY0jEI0&list=PLtgJR0xD2TPeVeq6azvnKXYSeYHFzGaMi
- https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world


# Happy building
